{"mappings":"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","sources":["src/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-empty-function */\nimport {\n  anticipate,\n  backIn,\n  backInOut,\n  backOut,\n  circIn,\n  circInOut,\n  circOut,\n  easeIn,\n  easeInOut,\n  easeOut,\n  linear,\n} from '@popmotion/easing';\nimport sync from 'framesync';\nimport throttle from 'lodash.throttle';\nimport { tween } from 'popmotion';\nimport {\n  BoundingClientRect,\n  CachedPositionData,\n  ChildBoundingClientRect,\n  Coords,\n  ItemPosition,\n  PopmotionEasing,\n  WrapGridArguments,\n} from './types';\n\nconst popmotionEasing: PopmotionEasing = {\n  anticipate,\n  backIn,\n  backInOut,\n  backOut,\n  circIn,\n  circInOut,\n  circOut,\n  easeIn,\n  easeInOut,\n  easeOut,\n  linear,\n};\n\nconst DATASET_KEY = 'animateGridId';\n\n// in order to account for scroll, (which we're not listening for)\n// always cache the item's position relative\n// to the top and left of the grid container\nconst getGridAwareBoundingClientRect = (\n  gridBoundingClientRect: BoundingClientRect,\n  el: HTMLElement\n): BoundingClientRect => {\n  const { top, left, width, height } = el.getBoundingClientRect();\n  const rect = { top, left, width, height };\n  rect.top -= gridBoundingClientRect.top;\n  rect.left -= gridBoundingClientRect.left;\n  // if an element is display:none it will return top: 0 and left:0\n  // rather than saying it's still in the containing element\n  // so we need to use Math.max to make sure the coordinates stay\n  // within the container\n  rect.top = Math.max(rect.top, 0);\n  rect.left = Math.max(rect.left, 0);\n  return rect;\n};\n\n// the function used during the tweening\nconst applyCoordTransform = (\n  el: HTMLElement,\n  { translateX, translateY, scaleX, scaleY }: Coords,\n  { immediate }: { immediate?: boolean } = {}\n): void => {\n  const isFinished =\n    translateX === 0 && translateY === 0 && scaleX === 1 && scaleY === 1;\n  const styleEl = () => {\n    el.style.transform = isFinished\n      ? ''\n      : `translateX(${translateX}px) translateY(${translateY}px) scaleX(${scaleX}) scaleY(${scaleY})`;\n  };\n  if (immediate) {\n    styleEl();\n  } else {\n    sync.render(styleEl);\n  }\n  const firstChild = el.children[0] as HTMLElement;\n  if (firstChild) {\n    const styleChild = () => {\n      firstChild.style.transform = isFinished\n        ? ''\n        : `scaleX(${1 / scaleX}) scaleY(${1 / scaleY})`;\n    };\n    if (immediate) {\n      styleChild();\n    } else {\n      sync.render(styleChild);\n    }\n  }\n};\n\n// return a function that take a reference to a grid dom node and optional config\nexport const wrapGrid = (\n  container: HTMLElement,\n  {\n    duration = 250,\n    stagger = 0,\n    easing = 'easeInOut',\n    onStart = () => { },\n    onEnd = () => { },\n  }: WrapGridArguments = {}\n) => {\n  if (!popmotionEasing[easing]) {\n    throw new Error(`${easing} is not a valid easing name`);\n  }\n\n  let mutationsDisabled = false;\n\n  const disableMutationsWhileFunctionRuns = (func: () => void) => {\n    mutationsDisabled = true;\n    func();\n    setTimeout(() => {\n      mutationsDisabled = false;\n    }, 0);\n  };\n\n  // all cached position data, and in-progress tween data, is stored here\n  const cachedPositionData: CachedPositionData = {};\n  // initially and after every transition, record element positions\n  const recordPositions = (\n    elements: HTMLCollectionOf<HTMLElement> | HTMLElement[]\n  ) => {\n    const gridBoundingClientRect = container.getBoundingClientRect();\n    Array.from(elements).forEach(el => {\n      if (typeof el.getBoundingClientRect !== 'function') {\n        return;\n      }\n      if (!el.dataset[DATASET_KEY]) {\n        const newId = `${Math.random()}`;\n        el.dataset[DATASET_KEY] = newId;\n      }\n      const animateGridId = el.dataset[DATASET_KEY] as string;\n\n      if (!cachedPositionData[animateGridId]) {\n        cachedPositionData[animateGridId] = {} as ItemPosition;\n      }\n\n      const rect = getGridAwareBoundingClientRect(gridBoundingClientRect, el);\n      cachedPositionData[animateGridId].rect = rect;\n      cachedPositionData[\n        animateGridId\n      ].gridBoundingClientRect = gridBoundingClientRect;\n    });\n  };\n  recordPositions(container.children as HTMLCollectionOf<HTMLElement>);\n\n  const throttledResizeListener = throttle(() => {\n    const bodyElement = document.querySelector('body');\n    const containerIsNoLongerInPage =\n      bodyElement && !bodyElement.contains(container);\n    if (!container || containerIsNoLongerInPage) {\n      window.removeEventListener('resize', throttledResizeListener);\n    }\n    recordPositions(container.children as HTMLCollectionOf<HTMLElement>);\n  }, 250);\n  window.addEventListener('resize', throttledResizeListener);\n\n  const throttledScrollListener = throttle(() => {\n    recordPositions(container.children as HTMLCollectionOf<HTMLElement>);\n  }, 20);\n  container.addEventListener('scroll', throttledScrollListener);\n\n  const mutationCallback = (\n    mutationsList: MutationRecord[] | 'forceGridAnimation'\n  ) => {\n    if (mutationsList !== 'forceGridAnimation') {\n      // check if we care about the mutation\n      const relevantMutationHappened = mutationsList.filter(\n        (m: MutationRecord) =>\n          m.attributeName === 'class' ||\n          m.addedNodes.length ||\n          m.removedNodes.length\n      ).length;\n      if (!relevantMutationHappened) {\n        return;\n      }\n      if (mutationsDisabled) return;\n    }\n    const gridBoundingClientRect = container.getBoundingClientRect();\n    const childrenElements = Array.from(container.children) as HTMLElement[];\n    // stop current transitions and remove transforms on transitioning elements\n    childrenElements\n      .filter(el => {\n        const itemPosition =\n          cachedPositionData[el.dataset[DATASET_KEY] as string];\n        if (itemPosition && itemPosition.stopTween) {\n          itemPosition.stopTween();\n          delete itemPosition.stopTween;\n          return true;\n        }\n      })\n      .forEach(el => {\n        el.style.transform = '';\n        const firstChild = el.children[0] as HTMLElement;\n        if (firstChild) {\n          firstChild.style.transform = '';\n        }\n      });\n    const animatedGridChildren = childrenElements\n      .map(el => ({\n        childCoords: {} as ChildBoundingClientRect,\n        el,\n        boundingClientRect: getGridAwareBoundingClientRect(\n          gridBoundingClientRect,\n          el\n        ),\n      }))\n      .filter(({ el, boundingClientRect }) => {\n        const itemPosition =\n          cachedPositionData[el.dataset[DATASET_KEY] as string];\n        // don't animate the initial appearance of elements,\n        // just cache their position so they can be animated later\n        if (!itemPosition) {\n          recordPositions([el]);\n          return false;\n        } else if (\n          boundingClientRect.top === itemPosition.rect.top &&\n          boundingClientRect.left === itemPosition.rect.left &&\n          boundingClientRect.width === itemPosition.rect.width &&\n          boundingClientRect.height === itemPosition.rect.height\n        ) {\n          // if it hasn't moved, dont animate it\n          return false;\n        }\n        return true;\n      });\n\n    // having more than one child in the animated item is not supported\n    animatedGridChildren.forEach(({ el }) => {\n      if (Array.from(el.children).length > 1) {\n        throw new Error(\n          'Make sure every grid item has a single container element surrounding its children'\n        );\n      }\n    });\n\n    if (!animatedGridChildren.length) {\n      return;\n    }\n\n    const animatedElements = animatedGridChildren.map(({ el }) => el);\n    disableMutationsWhileFunctionRuns(() => onStart(animatedElements));\n\n    const completionPromises: Array<Promise<unknown>> = [];\n\n    animatedGridChildren\n      // do this measurement first so as not to cause layout thrashing\n      .map(data => {\n        const firstChild = data.el.children[0] as HTMLElement;\n        // different transform origins give different effects. \"50% 50%\" is default\n        if (firstChild) {\n          data.childCoords = getGridAwareBoundingClientRect(\n            gridBoundingClientRect,\n            firstChild\n          );\n        }\n        return data;\n      })\n      .forEach(\n        (\n          {\n            el,\n            boundingClientRect: { top, left, width, height },\n            childCoords: { top: childTop, left: childLeft },\n          },\n          i\n        ) => {\n          const firstChild = el.children[0] as HTMLElement;\n          const itemPosition =\n            cachedPositionData[el.dataset[DATASET_KEY] as string];\n          const coords: Coords = {\n            scaleX: itemPosition.rect.width / width,\n            scaleY: itemPosition.rect.height / height,\n            translateX: itemPosition.rect.left - left,\n            translateY: itemPosition.rect.top - top,\n          };\n\n          el.style.transformOrigin = '0 0';\n          if (firstChild && childLeft === left && childTop === top) {\n            firstChild.style.transformOrigin = '0 0';\n          }\n\n          let cachedResolve: () => void;\n\n          const completionPromise = new Promise(resolve => {\n            cachedResolve = resolve as () => void;\n          });\n\n          completionPromises.push(completionPromise);\n\n          applyCoordTransform(el, coords, { immediate: true });\n          // now start the animation\n          const startAnimation = () => {\n            const { stop } = tween({\n              from: coords,\n              to: { translateX: 0, translateY: 0, scaleX: 1, scaleY: 1 },\n              duration,\n              ease: popmotionEasing[easing],\n            }).start({\n              update: (transforms: Coords) => {\n                applyCoordTransform(el, transforms);\n                // this helps prevent layout thrashing\n                sync.postRender(() => recordPositions([el]));\n              },\n              complete: cachedResolve,\n            });\n            itemPosition.stopTween = stop;\n          };\n\n          if (typeof stagger !== 'number') {\n            startAnimation();\n          } else {\n            const timeoutId = setTimeout(() => {\n              sync.update(startAnimation);\n            }, stagger * i);\n            itemPosition.stopTween = () => clearTimeout(timeoutId);\n          }\n        }\n      );\n\n    Promise.all(completionPromises).then(() => {\n      onEnd(animatedElements);\n    });\n  };\n\n  const observer = new MutationObserver(mutationCallback);\n  observer.observe(container, {\n    childList: true,\n    attributes: true,\n    subtree: true,\n    attributeFilter: ['class'],\n  });\n  const unwrapGrid = () => {\n    window.removeEventListener('resize', throttledResizeListener);\n    container.removeEventListener('scroll', throttledScrollListener);\n    observer.disconnect();\n  };\n  const forceGridAnimation = () => mutationCallback('forceGridAnimation');\n  return { unwrapGrid, forceGridAnimation };\n};\n"],"names":[],"version":3,"file":"main.js.map"}